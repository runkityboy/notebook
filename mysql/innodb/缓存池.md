### 1. 什么是缓存池&作用
存储最热的表数据和索引数据，避免每次访问都进行磁盘IO，提高TPS

### 2. 预读
#### 2.1 概念
mysql并不是按需取数据，每次至少读取一页。提前将未来可能使用的数据加载到内存，减少磁盘IO。

#### 2.2 预读为啥有效
数据的访问大部分情况下满足"局部性原理"，使用一些数据，大概率会使用附近的数据

### 3. 缓存池中页管理
#### 3.1 算法
LRU：Least recently used, 最近最少使用  

传统算法的带来两个问题：
-   `预读失效`
-   `缓存池污染`

#### 3.2 预读失效
从磁盘读取到缓存池中的page未被访问，一次预读会读入多个page

##### 3.2.1 预读算法
-   线性预读：下一个extent读取到缓存池
-   随机预读：将当前extent中剩余的page读取到缓存池

##### 3.2.2 优化方案
目标：
-   让预读失效的page尽可能的在缓存池存在时间少
-   只有真正被访问的page才放到LRU头部

具体方案：
-   LRU分为两段，新生代、老年代
-   新生代的tail节点和老年代的head节点相连
-   预读的page首先放到老年代的head节点，只有被访问了才被放到新生代的head节点

#### 3.3 缓存池污染
当某SQL会批量扫描大量数据时，可能导致缓存池中所有页(真正的热数据)都被替换出去。

##### 3.3.1 优化方案
引入老年代停留时间窗口

具体方案：
-   T = 老年代停留时间窗口
-   老年代中的页就算被访问过，也不会马上放入新生代
-   只有满足被访问 & 老年代停留的时间超过T才会被放入新生代

### 4. 涉及参数
- innodb_buffer_pool_size： 缓存池大小
- innodb_old_blocks_pct：老年代在整个LRU的占比，默认为37%
- innodb_old_blocks_time：老年代停留时间，毫秒
